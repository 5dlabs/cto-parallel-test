# Task ID: 3
# Title: User Authentication Module
# Status: pending
# Dependencies: None
# Priority: high
# Description: Create user authentication and JWT handling functionality.
# Details:
Implement the user authentication module with JWT token handling:

1. Create `src/auth/mod.rs` to export the auth module components:
```rust
pub mod jwt;
pub mod models;

pub use self::jwt::{create_token, validate_token};
pub use self::models::User;
```

2. Create `src/auth/jwt.rs` for JWT token handling:
```rust
use jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey};
use serde::{Serialize, Deserialize};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,  // Subject (user id)
    pub exp: usize,   // Expiration time
    pub iat: usize,   // Issued at
}

pub fn create_token(user_id: &str) -> Result<String, jsonwebtoken::errors::Error> {
    let expiration = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs() + 24 * 3600; // 24 hours from now
    
    let claims = Claims {
        sub: user_id.to_owned(),
        exp: expiration as usize,
        iat: SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs() as usize,
    };
    
    // In a real app, this would be a proper secret key
    let secret = b"test_secret_key";
    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret))
}

pub fn validate_token(token: &str) -> Result<Claims, jsonwebtoken::errors::Error> {
    let secret = b"test_secret_key";
    let validation = Validation::default();
    let token_data = decode::<Claims>(token, &DecodingKey::from_secret(secret), &validation)?;
    Ok(token_data.claims)
}
```

3. Create `src/auth/models.rs` for user model:
```rust
use serde::{Serialize, Deserialize};
use argon2::{self, Config};
use rand::Rng;

#[derive(Debug, Serialize, Deserialize)]
pub struct User {
    pub id: i32,
    pub username: String,
    pub email: String,
    #[serde(skip_serializing)]
    pub password_hash: String,
}

impl User {
    pub fn verify_password(&self, password: &str) -> bool {
        argon2::verify_encoded(&self.password_hash, password.as_bytes()).unwrap_or(false)
    }
    
    pub fn hash_password(password: &str) -> String {
        let salt = rand::thread_rng().gen::<[u8; 32]>();
        let config = Config::default();
        argon2::hash_encoded(password.as_bytes(), &salt, &config).unwrap()
    }
}
```

4. Update `Cargo.toml` to add authentication dependencies:
```toml
[dependencies]
jsonwebtoken = "8.3.0"
argon2 = "0.5.0"
rand = "0.8.5"
```

# Test Strategy:
1. Verify that all required files are created: `src/auth/mod.rs`, `src/auth/jwt.rs`, and `src/auth/models.rs`
2. Compile the code to ensure there are no syntax errors
3. Write unit tests to verify JWT token creation and validation
4. Test password hashing and verification functionality
5. Verify that the authentication dependencies in `Cargo.toml` are correctly specified and can be resolved
6. Check that the User model can be serialized and deserialized correctly

# Subtasks:
## 1. Set up authentication module structure [pending]
### Dependencies: None
### Description: Create the basic module structure for authentication including the mod.rs file and update Cargo.toml with required dependencies.
### Details:
1. Create the directory structure for auth module: `src/auth/`
2. Create `src/auth/mod.rs` with the exports as specified in the task
3. Update `Cargo.toml` to add the required dependencies:
   - jsonwebtoken = "8.3.0"
   - argon2 = "0.5.0"
   - rand = "0.8.5"

## 2. Implement JWT token handling [pending]
### Dependencies: 3.1
### Description: Create the JWT token handling functionality for creating and validating tokens.
### Details:
1. Create `src/auth/jwt.rs` file
2. Implement the Claims struct with sub, exp, and iat fields
3. Implement the create_token function that generates a JWT token with proper expiration
4. Implement the validate_token function that verifies a token and returns the claims
5. Use a constant secret key for development purposes (in production, this would be an environment variable)

## 3. Implement User model with password hashing [pending]
### Dependencies: 3.1
### Description: Create the User model with secure password handling using Argon2.
### Details:
1. Create `src/auth/models.rs` file
2. Implement the User struct with id, username, email, and password_hash fields
3. Implement the verify_password method that uses argon2 to verify a password against the stored hash
4. Implement the hash_password static method that generates a secure hash from a plaintext password
5. Ensure proper serialization/deserialization with serde attributes

## 4. Create user registration functionality [pending]
### Dependencies: 3.2, 3.3
### Description: Implement the functionality to register new users with secure password storage.
### Details:
1. Create a new function in models.rs to create a new user
2. Implement input validation for username, email, and password
3. Hash the password before storing
4. Ensure usernames and emails are unique
5. Return appropriate errors for validation failures

## 5. Implement login functionality and middleware [pending]
### Dependencies: 3.2, 3.3, 3.4
### Description: Create the login endpoint and authentication middleware for protected routes.
### Details:
1. Create a login function that validates credentials and returns a JWT token
2. Implement an authentication middleware that extracts and validates JWT tokens from requests
3. Create helper functions to get the current user from a request
4. Handle authentication errors with appropriate HTTP status codes
5. Ensure token refresh mechanism is in place

