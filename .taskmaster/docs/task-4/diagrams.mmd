```mermaid
graph TB
    subgraph "Product Catalog Module Architecture"
        ModRS[src/catalog/mod.rs<br/>Module Exports]
        ModelsRS[src/catalog/models.rs<br/>Data Structures]
        ServiceRS[src/catalog/service.rs<br/>Business Logic]

        ModRS -->|pub use| ModelsRS
        ModRS -->|pub use| ServiceRS
    end

    subgraph "Data Models"
        Product[Product<br/>id: i32<br/>name: String<br/>description: String<br/>price: Decimal<br/>inventory_count: i32]
        NewProduct[NewProduct<br/>name: String<br/>description: String<br/>price: Decimal<br/>inventory_count: i32]
        ProductFilter[ProductFilter<br/>name_contains: Option&lt;String&gt;<br/>min_price: Option&lt;Decimal&gt;<br/>max_price: Option&lt;Decimal&gt;<br/>in_stock: Option&lt;bool&gt;]

        ModelsRS --> Product
        ModelsRS --> NewProduct
        ModelsRS --> ProductFilter
    end

    subgraph "ProductService"
        Service[ProductService<br/>products: Arc&lt;Mutex&lt;Vec&lt;Product&gt;&gt;&gt;<br/>next_id: Arc&lt;Mutex&lt;i32&gt;&gt;]

        Create[create&#40;NewProduct&#41; → Product<br/>Auto-generate ID]
        GetAll[get_all&#40;&#41; → Vec&lt;Product&gt;<br/>Return all products]
        GetByID[get_by_id&#40;i32&#41; → Option&lt;Product&gt;<br/>Find by ID]
        UpdateInv[update_inventory&#40;i32, i32&#41; → Option&lt;Product&gt;<br/>Update stock]
        Filter[filter&#40;ProductFilter&#41; → Vec&lt;Product&gt;<br/>Query products]

        ServiceRS --> Service
        Service --> Create
        Service --> GetAll
        Service --> GetByID
        Service --> UpdateInv
        Service --> Filter
    end

    subgraph "Thread Safety"
        Arc[Arc&lt;T&gt;<br/>Atomic Reference Counting<br/>Shared ownership]
        Mutex[Mutex&lt;T&gt;<br/>Mutual Exclusion<br/>Thread-safe access]

        Service --> Arc
        Service --> Mutex
    end

    subgraph "Dependencies"
        RustDecimal[rust_decimal = &#34;1.30&#34;<br/>features = [&#34;serde&#34;]<br/>Precise decimal arithmetic]
        Serde[serde<br/>JSON serialization]
        StdSync[std::sync<br/>Arc, Mutex]

        Product -.->|uses| RustDecimal
        Product -.->|derives| Serde
        Service -.->|uses| StdSync
    end

    subgraph "Task 5 Integration"
        CartAPI[Shopping Cart API<br/>Task 5]
        ValidateProduct[Validate product exists]
        CheckInventory[Check stock availability]
        GetProductInfo[Get product details]

        CartAPI -->|calls| GetByID
        GetByID --> ValidateProduct
        GetByID --> CheckInventory
        GetByID --> GetProductInfo
    end

    style ModRS fill:#e1f5ff
    style ModelsRS fill:#e1f5ff
    style ServiceRS fill:#e1f5ff
    style Service fill:#fff3e0
    style Create fill:#c8e6c9
    style GetAll fill:#c8e6c9
    style GetByID fill:#c8e6c9
    style UpdateInv fill:#c8e6c9
    style Filter fill:#c8e6c9
    style Product fill:#f3e5f5
    style NewProduct fill:#f3e5f5
    style ProductFilter fill:#f3e5f5
    style Arc fill:#ffebee
    style Mutex fill:#ffebee
    style CartAPI fill:#fce4ec
```

```mermaid
sequenceDiagram
    participant Client
    participant Service as ProductService
    participant Storage as Arc<Mutex<Vec<Product>>>
    participant IDGen as Arc<Mutex<i32>>

    Note over Client,IDGen: Product Creation Flow

    Client->>Service: create(NewProduct)
    Service->>Storage: lock()
    Storage-->>Service: MutexGuard
    Service->>IDGen: lock()
    IDGen-->>Service: current_id = 1
    Service->>Service: Create Product with id=1
    Service->>IDGen: increment to 2
    Service->>Storage: push(product)
    Service->>Storage: unlock
    Service->>IDGen: unlock
    Service-->>Client: Product (cloned)

    Note over Client,IDGen: Product Query Flow

    Client->>Service: get_by_id(1)
    Service->>Storage: lock()
    Storage-->>Service: MutexGuard
    Service->>Storage: find(id == 1)
    Storage-->>Service: Some(product)
    Service->>Service: clone product
    Service->>Storage: unlock
    Service-->>Client: Some(Product)

    Note over Client,IDGen: Inventory Update Flow

    Client->>Service: update_inventory(1, 15)
    Service->>Storage: lock() [mutable]
    Storage-->>Service: MutexGuard
    Service->>Storage: find_mut(id == 1)
    Storage-->>Service: Some(&mut product)
    Service->>Storage: product.inventory_count = 15
    Service->>Service: clone updated product
    Service->>Storage: unlock
    Service-->>Client: Some(Product)

    Note over Client,IDGen: Product Filtering Flow

    Client->>Service: filter(ProductFilter)
    Service->>Storage: lock()
    Storage-->>Service: MutexGuard
    Service->>Service: Apply name filter (case-insensitive)
    Service->>Service: Apply min_price filter (>=)
    Service->>Service: Apply max_price filter (<=)
    Service->>Service: Apply in_stock filter
    Service->>Service: clone matching products
    Service->>Storage: unlock
    Service-->>Client: Vec<Product>
```

```mermaid
flowchart LR
    subgraph "Filter Logic Flow"
        Start([Filter Request]) --> HasName{name_contains<br/>is Some?}
        HasName -->|Yes| NameMatch[Check if product name<br/>contains substring<br/>case-insensitive]
        HasName -->|No| NamePass[Pass]
        NameMatch -->|Match| MinPrice{min_price<br/>is Some?}
        NameMatch -->|No Match| Exclude[Exclude Product]
        NamePass --> MinPrice

        MinPrice -->|Yes| MinCheck[Check if<br/>price >= min_price]
        MinPrice -->|No| MinPass[Pass]
        MinCheck -->|Pass| MaxPrice{max_price<br/>is Some?}
        MinCheck -->|Fail| Exclude
        MinPass --> MaxPrice

        MaxPrice -->|Yes| MaxCheck[Check if<br/>price <= max_price]
        MaxPrice -->|No| MaxPass[Pass]
        MaxCheck -->|Pass| Stock{in_stock<br/>is Some?}
        MaxCheck -->|Fail| Exclude
        MaxPass --> Stock

        Stock -->|Yes| StockCheck[Check if<br/>inventory_count > 0<br/>matches in_stock]
        Stock -->|No| StockPass[Pass]
        StockCheck -->|Match| Include[Include Product]
        StockCheck -->|No Match| Exclude
        StockPass --> Include
    end

    style Start fill:#e3f2fd
    style Include fill:#c8e6c9
    style Exclude fill:#ffcdd2
    style HasName fill:#fff9c4
    style MinPrice fill:#fff9c4
    style MaxPrice fill:#fff9c4
    style Stock fill:#fff9c4
```

```mermaid
graph TB
    subgraph "Level 0 Tasks - Parallel Execution"
        Task1[Task 1: Database Schema<br/>30 min]
        Task3[Task 3: User Auth<br/>45 min]
        Task4[Task 4: Product Catalog<br/>40 min]
        Task6[Task 6: Frontend<br/>35 min]
    end

    subgraph "Level 1 Tasks - Depends on Level 0"
        Task2[Task 2: API Endpoints<br/>Depends: Task 1<br/>50 min]
        Task5[Task 5: Shopping Cart API<br/>Depends: Tasks 3, 4<br/>45 min]
    end

    subgraph "Level 2 Tasks - Final Integration"
        Task7[Task 7: Integration Tests<br/>Depends: Tasks 2, 5, 6<br/>60 min]
    end

    Task1 --> Task2
    Task3 --> Task5
    Task4 --> Task5
    Task2 --> Task7
    Task5 --> Task7
    Task6 --> Task7

    style Task4 fill:#ffd54f,stroke:#f57c00,stroke-width:4px
    style Task5 fill:#ffecb3,stroke:#f57c00,stroke-width:2px
    style Task7 fill:#ffecb3,stroke:#f57c00,stroke-width:2px

    classDef level0 fill:#e1f5fe
    classDef level1 fill:#fff3e0
    classDef level2 fill:#f3e5f5

    class Task1,Task3,Task4,Task6 level0
    class Task2,Task5 level1
    class Task7 level2
```
