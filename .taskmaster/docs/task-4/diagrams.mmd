```mermaid
classDiagram
    class Product {
        +i32 id
        +String name
        +String description
        +Decimal price
        +i32 inventory_count
    }

    class NewProduct {
        +String name
        +String description
        +Decimal price
        +i32 inventory_count
    }

    class ProductFilter {
        +Option~String~ name_contains
        +Option~Decimal~ min_price
        +Option~Decimal~ max_price
        +Option~bool~ in_stock
    }

    class ProductService {
        -Arc~Mutex~Vec~Product~~~ products
        -Arc~Mutex~i32~~ next_id
        +new() ProductService
        +create(NewProduct) Product
        +get_all() Vec~Product~
        +get_by_id(i32) Option~Product~
        +update_inventory(i32, i32) Option~Product~
        +filter(ProductFilter) Vec~Product~
    }

    ProductService ..> Product : manages
    ProductService ..> NewProduct : accepts
    ProductService ..> ProductFilter : uses
    NewProduct ..|> Product : becomes

    note for Product "Full product with ID\n(stored in catalog)"
    note for NewProduct "Product without ID\n(for creation)"
    note for ProductFilter "Optional filter criteria\n(None = no filter)"
    note for ProductService "Thread-safe in-memory service\nArc+Mutex for concurrency"
```

```mermaid
sequenceDiagram
    participant Client
    participant Service as ProductService
    participant Storage as Arc<Mutex<Vec<Product>>>
    participant Counter as Arc<Mutex<i32>>

    Note over Client,Counter: Product Creation Flow

    Client->>Service: create(NewProduct)
    Service->>Storage: lock()
    Storage-->>Service: MutexGuard
    Service->>Counter: lock()
    Counter-->>Service: ID (e.g., 1)
    Service->>Counter: increment (ID = 2)
    Service->>Service: Build Product<br/>(ID + NewProduct data)
    Service->>Storage: push(Product)
    Service->>Storage: unlock()
    Service->>Counter: unlock()
    Service-->>Client: Product (with ID)

    Note over Client,Counter: Product Retrieval Flow

    Client->>Service: get_by_id(1)
    Service->>Storage: lock()
    Storage-->>Service: MutexGuard
    Service->>Storage: find(id == 1)
    Storage-->>Service: Product
    Service->>Service: clone()
    Service->>Storage: unlock()
    Service-->>Client: Option<Product>

    Note over Client,Counter: Product Filtering Flow

    Client->>Service: filter(ProductFilter)
    Service->>Storage: lock()
    Storage-->>Service: MutexGuard
    loop Each Product
        Service->>Service: Apply name filter
        Service->>Service: Apply price filters
        Service->>Service: Apply stock filter
        alt All filters match
            Service->>Service: Include in results
        else Any filter fails
            Service->>Service: Exclude
        end
    end
    Service->>Service: collect filtered products
    Service->>Storage: unlock()
    Service-->>Client: Vec<Product>
```

```mermaid
graph TB
    subgraph "Product Service Architecture"
        PS[ProductService<br/>Public Interface]
        Products[(Arc&lt;Mutex&lt;Vec&lt;Product&gt;&gt;&gt;<br/>Thread-safe Storage)]
        NextID[(Arc&lt;Mutex&lt;i32&gt;&gt;<br/>ID Counter)]
    end

    subgraph "CRUD Operations"
        Create[create<br/>NewProduct → Product<br/>Assigns ID]
        GetAll[get_all<br/>→ Vec&lt;Product&gt;<br/>Returns all]
        GetByID[get_by_id<br/>i32 → Option&lt;Product&gt;<br/>Finds by ID]
        UpdateInv[update_inventory<br/>i32, i32 → Option&lt;Product&gt;<br/>Modifies stock]
    end

    subgraph "Filtering"
        Filter[filter<br/>ProductFilter → Vec&lt;Product&gt;]
        NameF[Name Contains<br/>Case-insensitive]
        PriceF[Price Range<br/>Min/Max inclusive]
        StockF[In Stock<br/>Count &gt; 0]
    end

    PS --> Create
    PS --> GetAll
    PS --> GetByID
    PS --> UpdateInv
    PS --> Filter

    Create --> Products
    Create --> NextID
    GetAll --> Products
    GetByID --> Products
    UpdateInv --> Products

    Filter --> Products
    Filter --> NameF
    Filter --> PriceF
    Filter --> StockF

    NameF -.AND.-> PriceF
    PriceF -.AND.-> StockF

    classDef storage fill:#FFE4B5,stroke:#FF8C00,stroke-width:2px
    classDef operation fill:#90EE90,stroke:#006400,stroke-width:2px
    classDef filter fill:#87CEEB,stroke:#4682B4,stroke-width:2px

    class Products,NextID storage
    class Create,GetAll,GetByID,UpdateInv operation
    class Filter,NameF,PriceF,StockF filter
```

```mermaid
graph LR
    subgraph "Thread Safety Model"
        T1[Thread 1<br/>Create Product]
        T2[Thread 2<br/>Get Product]
        T3[Thread 3<br/>Update Inventory]

        Service[ProductService<br/>Shared Instance]

        M1[Mutex<br/>Products]
        M2[Mutex<br/>NextID]
    end

    T1 -->|clone Arc| Service
    T2 -->|clone Arc| Service
    T3 -->|clone Arc| Service

    Service -->|lock when needed| M1
    Service -->|lock when needed| M2

    M1 -->|guards| Data[(Vec&lt;Product&gt;)]
    M2 -->|guards| ID[i32 counter]

    note1[Separate locks minimize contention<br/>Arc allows sharing<br/>Mutex ensures safe mutation]

    style Service fill:#FFD700,stroke:#FF8C00,stroke-width:3px
    style M1 fill:#FF6B6B,stroke:#C92A2A,stroke-width:2px
    style M2 fill:#FF6B6B,stroke:#C92A2A,stroke-width:2px
    style Data fill:#90EE90,stroke:#006400,stroke-width:2px
    style ID fill:#90EE90,stroke:#006400,stroke-width:2px
```

```mermaid
graph TD
    subgraph "Filtering Logic Flow"
        Start[ProductFilter Input]
        Products[(All Products)]

        NC{name_contains<br/>Some?}
        NM[Match substring<br/>case-insensitive]
        NP[Pass all<br/>None = no filter]

        MP{min_price<br/>Some?}
        MPM[price &gt;= min_price]
        MPP[Pass all]

        MXP{max_price<br/>Some?}
        MXPM[price &lt;= max_price]
        MXPP[Pass all]

        IS{in_stock<br/>Some?}
        ISM[inventory_count &gt; 0<br/>matches bool]
        ISP[Pass all]

        AND[Combine with AND<br/>All must match]
        Result[Filtered Products]
    end

    Start --> Products
    Products --> NC

    NC -->|Some| NM
    NC -->|None| NP

    NM --> MP
    NP --> MP

    MP -->|Some| MPM
    MP -->|None| MPP

    MPM --> MXP
    MPP --> MXP

    MXP -->|Some| MXPM
    MXP -->|None| MXPP

    MXPM --> IS
    MXPP --> IS

    IS -->|Some| ISM
    IS -->|None| ISP

    ISM --> AND
    ISP --> AND

    AND --> Result

    style Start fill:#87CEEB,stroke:#4682B4,stroke-width:2px
    style AND fill:#FF6B6B,stroke:#C92A2A,stroke-width:3px
    style Result fill:#90EE90,stroke:#006400,stroke-width:2px
```
