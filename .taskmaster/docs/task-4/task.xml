<?xml version="1.0" encoding="UTF-8"?>
<prompt>
    <role>You are a senior Rust backend developer specializing in service layer architecture, data modeling, and concurrent programming.</role>

    <task>
        <id>4</id>
        <title>Product Catalog Module</title>
        <description>Create product catalog and inventory management functionality for the Rust API project. Implement product data models with precise decimal pricing, thread-safe in-memory service with CRUD operations, advanced filtering capabilities (price range, stock status, name search), and inventory management. This provides the product foundation for the shopping cart.</description>
        <priority>high</priority>
        <status>pending</status>
        <dependencies></dependencies>
        <level>0</level>
        <estimated_time>40 minutes</estimated_time>
    </task>

    <technical_specifications>
        <spec>Use rust_decimal 1.30 with serde features for precise monetary calculations</spec>
        <spec>Implement thread-safe service using Arc and Mutex for concurrent access</spec>
        <spec>Create three model types: Product, NewProduct, ProductFilter</spec>
        <spec>Implement CRUD operations: create, get_all, get_by_id, update_inventory</spec>
        <spec>Implement advanced filtering with multiple optional criteria</spec>
        <spec>Use auto-incrementing ID counter starting at 1</spec>
        <spec>Store products in-memory using Vec</spec>
        <spec>Ensure service is Send + Sync for web server threading</spec>
    </technical_specifications>

    <implementation_details>
        <overview>This task creates a complete product catalog module with models and service logic. It is a Level 0 task that runs independently and provides product management for Task 5 (Shopping Cart API).</overview>

        <step number="1">
            <action>Update Cargo.toml with decimal dependency</action>
            <details>
                Add to [dependencies] section:
                - rust_decimal = { version = "1.30", features = ["serde"] }

                This provides precise decimal arithmetic for prices, avoiding floating-point errors.
            </details>
        </step>

        <step number="2">
            <action>Create src/catalog/mod.rs with module exports</action>
            <details>
                Declare submodules:
                - pub mod models;
                - pub mod service;

                Re-export key components:
                - pub use self::models::Product;
                - pub use self::service::ProductService;

                This provides clean public API for module consumers.
            </details>
        </step>

        <step number="3">
            <action>Create src/catalog/models.rs with data models</action>
            <details>
                Import required types:
                - use serde::{Serialize, Deserialize};
                - use rust_decimal::Decimal;

                Define Product struct:
                - #[derive(Debug, Serialize, Deserialize, Clone)]
                - pub struct Product with fields:
                  * pub id: i32
                  * pub name: String
                  * pub description: String
                  * pub price: Decimal
                  * pub inventory_count: i32

                Define NewProduct struct (for creation):
                - #[derive(Debug, Serialize, Deserialize)]
                - pub struct NewProduct with fields:
                  * pub name: String
                  * pub description: String
                  * pub price: Decimal
                  * pub inventory_count: i32

                Define ProductFilter struct (for querying):
                - #[derive(Debug, Serialize, Deserialize)]
                - pub struct ProductFilter with fields:
                  * pub name_contains: Option&lt;String&gt;
                  * pub min_price: Option&lt;Decimal&gt;
                  * pub max_price: Option&lt;Decimal&gt;
                  * pub in_stock: Option&lt;bool&gt;
            </details>
        </step>

        <step number="4">
            <action>Create src/catalog/service.rs with ProductService implementation</action>
            <details>
                Import required types:
                - use crate::catalog::models::{Product, NewProduct, ProductFilter};
                - use rust_decimal::Decimal;
                - use std::sync::{Arc, Mutex};

                Define ProductService struct:
                - pub struct ProductService with fields:
                  * products: Arc&lt;Mutex&lt;Vec&lt;Product&gt;&gt;&gt;
                  * next_id: Arc&lt;Mutex&lt;i32&gt;&gt;

                Implement new() constructor:
                - Signature: pub fn new() -&gt; Self
                - Initialize products: Arc::new(Mutex::new(Vec::new()))
                - Initialize next_id: Arc::new(Mutex::new(1))
                - Return ProductService instance

                Implement create() method:
                - Signature: pub fn create(&amp;self, new_product: NewProduct) -&gt; Product
                - Lock products: let mut products = self.products.lock().unwrap()
                - Lock next_id: let mut next_id = self.next_id.lock().unwrap()
                - Assign ID: let id = *next_id
                - Increment: *next_id += 1
                - Create product: Product { id, name: new_product.name, ... }
                - Push to vector: products.push(product.clone())
                - Return cloned product

                Implement get_all() method:
                - Signature: pub fn get_all(&amp;self) -&gt; Vec&lt;Product&gt;
                - Lock products: let products = self.products.lock().unwrap()
                - Return: products.clone()

                Implement get_by_id() method:
                - Signature: pub fn get_by_id(&amp;self, id: i32) -&gt; Option&lt;Product&gt;
                - Lock products: let products = self.products.lock().unwrap()
                - Find: products.iter().find(|p| p.id == id)
                - Return: cloned product or None

                Implement update_inventory() method:
                - Signature: pub fn update_inventory(&amp;self, id: i32, new_count: i32) -&gt; Option&lt;Product&gt;
                - Lock products mutably: let mut products = self.products.lock().unwrap()
                - Find mutable: products.iter_mut().find(|p| p.id == id)
                - Update: product.inventory_count = new_count
                - Return: cloned updated product or None

                Implement filter() method:
                - Signature: pub fn filter(&amp;self, filter: ProductFilter) -&gt; Vec&lt;Product&gt;
                - Lock products: let products = self.products.lock().unwrap()
                - Filter chain:
                  * name_contains: filter.name_contains.as_ref().map_or(true, |name| p.name.to_lowercase().contains(&amp;name.to_lowercase()))
                  * min_price: filter.min_price.as_ref().map_or(true, |min| p.price &gt;= *min)
                  * max_price: filter.max_price.as_ref().map_or(true, |max| p.price &lt;= *max)
                  * in_stock: filter.in_stock.map_or(true, |in_stock| (p.inventory_count &gt; 0) == in_stock)
                - Combine with AND: name_match &amp;&amp; min_price_match &amp;&amp; max_price_match &amp;&amp; in_stock_match
                - Collect: .cloned().collect()
                - Return filtered vector
            </details>
        </step>

        <step number="5">
            <action>Verify compilation and functionality</action>
            <details>
                Run cargo check to verify compilation
                Test product creation:
                - Create service
                - Add products
                - Verify sequential IDs (1, 2, 3, ...)

                Test retrieval:
                - get_all returns all products
                - get_by_id finds correct product
                - get_by_id returns None for non-existent

                Test inventory:
                - Update inventory for existing product
                - Verify get_by_id reflects update

                Test filtering:
                - Empty filter returns all
                - Name filter (case-insensitive)
                - Price range filter
                - In stock filter
                - Combined filters
            </details>
        </step>

        <step number="6">
            <action>Create unit tests for catalog module</action>
            <details>
                Add test module at end of service.rs:
                - Test product creation and ID assignment
                - Test get_all and get_by_id
                - Test inventory updates
                - Test filtering with various criteria
                - Test thread safety (if desired)

                Run: cargo test catalog
            </details>
        </step>
    </implementation_details>

    <acceptance_criteria>
        <criterion>Files src/catalog/mod.rs, src/catalog/models.rs, and src/catalog/service.rs exist with complete implementations</criterion>
        <criterion>Cargo.toml includes rust_decimal dependency with serde features</criterion>
        <criterion>Product model has id, name, description, price (Decimal), and inventory_count fields</criterion>
        <criterion>NewProduct model excludes id field (for creation)</criterion>
        <criterion>ProductFilter has optional name_contains, min_price, max_price, and in_stock fields</criterion>
        <criterion>ProductService uses Arc&lt;Mutex&lt;&gt;&gt; for thread-safe concurrent access</criterion>
        <criterion>create() method assigns sequential IDs starting from 1</criterion>
        <criterion>get_all() returns all products in the catalog</criterion>
        <criterion>get_by_id() finds products by ID or returns None</criterion>
        <criterion>update_inventory() modifies product inventory and persists changes</criterion>
        <criterion>filter() applies name, price range, and stock filters with AND logic</criterion>
        <criterion>Filter treats None values as no constraint (matches all)</criterion>
        <criterion>Name filtering is case-insensitive substring match</criterion>
        <criterion>Price filtering uses inclusive comparisons (greater-than-or-equal, less-than-or-equal)</criterion>
        <criterion>cargo check and cargo build complete without errors</criterion>
        <criterion>All unit tests pass</criterion>
        <criterion>Service is Send + Sync (thread-safe)</criterion>
    </acceptance_criteria>

    <test_strategy>
        <validation>
            Manual validation steps:

            1. Verify file existence:
               - ls -la src/catalog/mod.rs
               - ls -la src/catalog/models.rs
               - ls -la src/catalog/service.rs

            2. Check compilation:
               - cargo check
               - cargo build

            3. Validate dependencies:
               - cargo tree | grep rust_decimal

            4. Run unit tests:
               - cargo test catalog

            5. Test product creation:
               - Create service
               - Create multiple products
               - Verify IDs are sequential (1, 2, 3)

            6. Test retrieval:
               - get_all returns correct count
               - get_by_id finds existing products
               - get_by_id returns None for missing ID

            7. Test inventory:
               - Update inventory for product
               - Retrieve same product
               - Verify inventory reflects update

            8. Test filtering:
               - Create products with various attributes
               - Test name filter (case-insensitive)
               - Test price range filters
               - Test in_stock filter
               - Test combined filters
               - Verify AND logic
        </validation>

        <unit_testing>
            Implement tests for:

            1. Product creation:
               - Sequential ID assignment
               - All fields copied correctly

            2. Retrieval operations:
               - get_all returns all products
               - get_by_id finds correct product
               - get_by_id handles missing ID

            3. Inventory management:
               - Update persists correctly
               - Retrieval reflects update

            4. Filtering:
               - Empty filter returns all
               - Name filter (case variations)
               - Min price filter
               - Max price filter
               - In stock true/false
               - Combined filters (multiple criteria)
        </unit_testing>

        <integration_testing>
            This task enables:
            - Task 5 to look up products for cart operations
            - Task 5 to check inventory before adding to cart
            - Task 7 to test product API endpoints

            Verify Task 5 can:
            - Import ProductService
            - Import Product model
            - Call get_by_id to validate products
            - Check inventory_count before cart operations
        </integration_testing>
    </test_strategy>

    <instructions>
        Think step-by-step and follow the implementation plan exactly.

        1. Update Cargo.toml with rust_decimal dependency first
        2. Create the module structure (mod.rs) with proper exports
        3. Implement all three data models in models.rs
        4. Implement complete ProductService in service.rs with all methods
        5. Ensure thread safety with Arc&lt;Mutex&lt;&gt;&gt;
        6. Verify compilation and all operations work correctly
        7. Write and run unit tests for all functionality

        Key implementation details:
        - Use rust_decimal::Decimal for prices (not f32/f64)
        - Separate locks for products and next_id minimizes contention
        - Clone products on return to avoid holding locks
        - Filter with map_or(true, ...) for None = no constraint
        - Case-insensitive name search improves UX
        - All filters combine with AND logic

        This is a Level 0 task with no dependencies - start immediately.
        Task 5 (Shopping Cart) depends on your product lookup.
        Task 7 (Integration Tests) will test your catalog operations.

        Keep implementations clean and well-documented.
        Focus on correctness and thread safety.
        In-memory storage is acceptable for this test project.
    </instructions>

    <context>
        <project>
            <name>Parallel Task Execution Test</name>
            <repository>https://github.com/5dlabs/cto-parallel-test</repository>
            <purpose>Testing parallel task orchestration, dependency management, and conflict detection</purpose>
        </project>

        <architecture>
            <component>Product Catalog Layer</component>
            <technology>Rust + rust_decimal + Arc/Mutex</technology>
            <pattern>Service pattern with in-memory storage</pattern>
            <integration>Provides product data and inventory for shopping cart</integration>
        </architecture>

        <execution_context>
            <level>0</level>
            <depends_on>None (independent task)</depends_on>
            <enables>Task 5 (Shopping Cart product validation), Task 7 (Integration tests)</enables>
            <parallel_with>Tasks 1, 3, 6</parallel_with>
        </execution_context>

        <design_decisions>
            <decision>Use rust_decimal for exact decimal arithmetic in monetary calculations</decision>
            <decision>Arc&lt;Mutex&lt;&gt;&gt; provides thread safety for concurrent web server access</decision>
            <decision>Clone on return avoids holding locks during consumer processing</decision>
            <decision>In-memory Vec storage is simple and sufficient for test project</decision>
            <decision>Sequential ID counter simplifies creation logic</decision>
            <decision>Optional filter fields with map_or pattern for flexibility</decision>
        </design_decisions>

        <constraints>
            <constraint>In-memory storage (not persistent)</constraint>
            <constraint>Linear search for ID lookup (acceptable for test scale)</constraint>
            <constraint>Keep implementations straightforward for testing purposes</constraint>
            <constraint>Thread-safe service required for Actix-web integration</constraint>
        </constraints>
    </context>
</prompt>
