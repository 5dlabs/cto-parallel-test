<?xml version="1.0" encoding="UTF-8"?>
<prompt>
    <role>You are a senior Rust backend developer specializing in service architecture, concurrent programming, and e-commerce systems with expertise in thread-safe data structures and precise financial calculations.</role>
    <task>
        <id>4</id>
        <title>Product Catalog Module</title>
        <description>Create product catalog and inventory management functionality for the Rust API project. Implement product models using rust_decimal for precise price handling, ProductService with in-memory thread-safe storage using Arc and Mutex, and comprehensive CRUD operations including product filtering by name, price range, and stock status.</description>
        <priority>high</priority>
        <status>pending</status>
        <dependencies></dependencies>
        <level>0</level>
        <estimated_time>40 minutes</estimated_time>
    </task>
    <technical_specifications>
        <spec>Use rust_decimal crate version 1.30+ with serde feature for precise monetary calculations</spec>
        <spec>Define three core structs: Product (with ID), NewProduct (without ID), and ProductFilter (with optional query fields)</spec>
        <spec>Implement ProductService with Arc&lt;Mutex&lt;Vec&lt;Product&gt;&gt;&gt; for thread-safe in-memory storage</spec>
        <spec>Support auto-incrementing product IDs starting from 1</spec>
        <spec>Implement CRUD operations: create, get_all, get_by_id, update_inventory</spec>
        <spec>Implement flexible filtering with AND logic for: name_contains, min_price, max_price, in_stock</spec>
        <spec>Use case-insensitive name matching for product searches</spec>
        <spec>Return cloned products to avoid holding mutex locks longer than necessary</spec>
        <spec>All price fields must use rust_decimal::Decimal type, never f32 or f64</spec>
    </technical_specifications>
    <implementation_details>
        <step>
            <number>1</number>
            <action>Create catalog module structure</action>
            <details>
                Create src/catalog/mod.rs with module declarations and exports:

                pub mod models;
                pub mod service;

                pub use self::models::Product;
                pub use self::service::ProductService;

                This establishes the catalog module and makes key types available for import by other modules. The pub use statements allow other code to import Product and ProductService directly from the catalog module without needing to know the internal structure.
            </details>
        </step>
        <step>
            <number>2</number>
            <action>Define product models</action>
            <details>
                Create src/catalog/models.rs with three data structures:

                1. Product struct with fields:
                   - id: i32 (auto-generated primary key)
                   - name: String (product name)
                   - description: String (product description)
                   - price: rust_decimal::Decimal (precise price value)
                   - inventory_count: i32 (stock quantity)
                   Derives: Debug, Serialize, Deserialize, Clone

                2. NewProduct struct with fields:
                   - name: String
                   - description: String
                   - price: rust_decimal::Decimal
                   - inventory_count: i32
                   (No id field - will be generated by service)
                   Derives: Debug, Serialize, Deserialize

                3. ProductFilter struct with optional query fields:
                   - name_contains: Option&lt;String&gt; (partial name match)
                   - min_price: Option&lt;Decimal&gt; (minimum price inclusive)
                   - max_price: Option&lt;Decimal&gt; (maximum price inclusive)
                   - in_stock: Option&lt;bool&gt; (true = inventory &gt; 0)
                   Derives: Debug, Serialize, Deserialize

                Import required types:
                - use serde::{Serialize, Deserialize};
                - use rust_decimal::Decimal;

                The use of rust_decimal::Decimal for price fields ensures precise decimal arithmetic without floating-point errors, which is critical for financial calculations.
            </details>
        </step>
        <step>
            <number>3</number>
            <action>Implement ProductService with thread-safe storage</action>
            <details>
                Create src/catalog/service.rs with ProductService implementation:

                Structure:
                pub struct ProductService {
                    products: Arc&lt;Mutex&lt;Vec&lt;Product&gt;&gt;&gt;,
                    next_id: Arc&lt;Mutex&lt;i32&gt;&gt;,
                }

                The Arc (Atomic Reference Counted) allows sharing ownership across threads, and Mutex ensures only one thread can access the data at a time, providing thread safety for the in-memory storage.

                Implement the following methods:

                1. new() -&gt; Self
                   Initialize empty products vector and next_id = 1

                2. create(&amp;self, new_product: NewProduct) -&gt; Product
                   - Lock both products and next_id mutexes
                   - Create Product with current next_id
                   - Increment next_id
                   - Push product to vector
                   - Return cloned product

                3. get_all(&amp;self) -&gt; Vec&lt;Product&gt;
                   - Lock products mutex
                   - Clone and return all products

                4. get_by_id(&amp;self, id: i32) -&gt; Option&lt;Product&gt;
                   - Lock products mutex
                   - Find product with matching id
                   - Return cloned product if found, None otherwise

                5. update_inventory(&amp;self, id: i32, new_count: i32) -&gt; Option&lt;Product&gt;
                   - Lock products mutex (mutable)
                   - Find product with matching id
                   - Update inventory_count if found
                   - Return cloned updated product or None

                6. filter(&amp;self, filter: ProductFilter) -&gt; Vec&lt;Product&gt;
                   - Lock products mutex
                   - Filter products where ALL criteria match:
                     * name_contains: case-insensitive partial match (if Some)
                     * min_price: price &gt;= min_price (if Some)
                     * max_price: price &lt;= max_price (if Some)
                     * in_stock: (inventory_count &gt; 0) == in_stock (if Some)
                   - Return cloned filtered products

                Import required types:
                - use crate::catalog::models::{Product, NewProduct, ProductFilter};
                - use rust_decimal::Decimal;
                - use std::sync::{Arc, Mutex};

                Important: Always clone products before returning to release mutex locks quickly and avoid holding locks while the caller processes the data.
            </details>
        </step>
        <step>
            <number>4</number>
            <action>Update Cargo.toml dependencies</action>
            <details>
                Add rust_decimal dependency to the [dependencies] section of Cargo.toml:

                rust_decimal = { version = "1.30", features = ["serde"] }

                The rust_decimal crate provides:
                - Exact decimal arithmetic for monetary values
                - No floating-point precision errors (e.g., 0.1 + 0.2 = 0.3 exactly)
                - The serde feature enables automatic JSON serialization/deserialization

                This dependency is critical for handling prices correctly in an e-commerce system. Never use f32 or f64 for monetary values as they can introduce rounding errors.

                Note: This task and Task 1 both modify Cargo.toml. This is expected and the CTO platform will handle merging the dependencies from both tasks.
            </details>
        </step>
        <step>
            <number>5</number>
            <action>Validate implementation</action>
            <details>
                Run validation checks to ensure correctness:

                1. File structure check:
                   ls -la src/catalog/mod.rs
                   ls -la src/catalog/models.rs
                   ls -la src/catalog/service.rs

                2. Compilation check:
                   cargo check

                   Must complete without errors or warnings. Verify that:
                   - All structs compile correctly
                   - rust_decimal types work properly
                   - Arc and Mutex usage is correct
                   - All methods have correct signatures

                3. Dependency verification:
                   grep "rust_decimal" Cargo.toml

                   Should show rust_decimal with version 1.30 and serde feature.

                4. Module import test (conceptual):
                   Verify that other modules can import:
                   use crate::catalog::{Product, ProductService};

                Do not mark the task complete if any validation fails. Fix issues and re-validate.
            </details>
        </step>
    </implementation_details>
    <acceptance_criteria>
        <criterion>src/catalog/mod.rs file exists and contains module declarations for models and service with pub use exports for Product and ProductService</criterion>
        <criterion>src/catalog/models.rs file exists and contains Product struct with fields id, name, description, price (Decimal), and inventory_count</criterion>
        <criterion>Product struct derives Debug, Serialize, Deserialize, and Clone traits</criterion>
        <criterion>NewProduct struct exists with same fields as Product except id, deriving Debug, Serialize, Deserialize</criterion>
        <criterion>ProductFilter struct exists with optional fields name_contains, min_price, max_price, in_stock</criterion>
        <criterion>All price fields use rust_decimal::Decimal type, never f32 or f64</criterion>
        <criterion>src/catalog/service.rs file exists with ProductService struct containing Arc&lt;Mutex&lt;Vec&lt;Product&gt;&gt;&gt; and Arc&lt;Mutex&lt;i32&gt;&gt; fields</criterion>
        <criterion>ProductService implements new() method that initializes empty storage with next_id = 1</criterion>
        <criterion>ProductService implements create() method with auto-incrementing IDs</criterion>
        <criterion>ProductService implements get_all() method returning all products</criterion>
        <criterion>ProductService implements get_by_id() method returning Option&lt;Product&gt;</criterion>
        <criterion>ProductService implements update_inventory() method for stock management</criterion>
        <criterion>ProductService implements filter() method supporting name, price range, and stock filters with AND logic</criterion>
        <criterion>Filter name matching is case-insensitive</criterion>
        <criterion>All service methods use proper mutex locking and return cloned products</criterion>
        <criterion>Cargo.toml includes rust_decimal dependency version 1.30+ with serde feature</criterion>
        <criterion>Code passes 'cargo check' without compilation errors or warnings</criterion>
        <criterion>Module is properly organized and can be imported by other modules</criterion>
        <criterion>Thread-safe design allows ProductService to be shared across multiple threads</criterion>
    </acceptance_criteria>
    <test_strategy>
        Validation approach for the product catalog module:

        1. Compilation Testing:
           - Run 'cargo check' to verify syntax and type correctness
           - Ensure no compilation errors or warnings
           - Verify rust_decimal dependency resolves correctly
           - Check that Arc and Mutex types are used properly

        2. File Structure Verification:
           - Confirm src/catalog/mod.rs exists with proper exports
           - Verify src/catalog/models.rs contains all three structs
           - Check src/catalog/service.rs has complete implementation
           - Validate Cargo.toml has rust_decimal dependency

        3. Type Safety Checks:
           - Verify all price fields use Decimal, not floating-point
           - Check Option&lt;T&gt; is used for nullable/optional values
           - Ensure proper use of references vs owned values
           - Validate method signatures match specifications

        4. Thread Safety Verification:
           - Confirm Arc&lt;Mutex&lt;&gt;&gt; pattern used correctly
           - Check that locks are acquired and released properly
           - Verify products are cloned before returning
           - Ensure no potential deadlocks or race conditions

        5. Functionality Validation (conceptual):
           - create() generates sequential IDs starting from 1
           - get_all() returns all stored products
           - get_by_id() returns correct product or None
           - update_inventory() modifies stock correctly
           - filter() applies all criteria with AND logic
           - name_contains is case-insensitive

        6. Integration Readiness:
           - Module can be imported: use crate::catalog::*;
           - ProductService can be instantiated
           - Service can be shared as web::Data in actix-web
           - Ready for Task 5 (Shopping Cart API) to use

        7. Commands to execute:
           cargo check
           ls -la src/catalog/
           cat src/catalog/mod.rs
           grep -A 2 "rust_decimal" Cargo.toml

        8. Manual verification:
           - Review all struct definitions
           - Check all method implementations
           - Verify filter logic correctness
           - Confirm thread-safety patterns
    </test_strategy>
    <instructions>
        You are implementing Task 4: Product Catalog Module for a parallel task execution test project.

        CRITICAL INSTRUCTIONS:
        - This is a Level 0 task with NO dependencies - proceed immediately without waiting
        - Create exactly the files specified: src/catalog/mod.rs, src/catalog/models.rs, src/catalog/service.rs
        - Update Cargo.toml to add rust_decimal dependency
        - Use the exact struct definitions and method signatures provided in the specifications
        - This is a test project - use in-memory storage, not a database
        - File conflicts with Task 1 on Cargo.toml are expected and acceptable - the CTO platform will merge them
        - Task 5 (Shopping Cart API) depends on this task being complete

        IMPLEMENTATION APPROACH:
        1. Create the catalog directory structure under src/
        2. Start with models.rs to define data structures
        3. Implement service.rs with all CRUD and filter operations
        4. Create mod.rs to export the public API
        5. Update Cargo.toml with rust_decimal dependency
        6. Validate with cargo check before marking complete

        QUALITY STANDARDS:
        - All price fields MUST use rust_decimal::Decimal, never f32 or f64
        - Use Arc&lt;Mutex&lt;&gt;&gt; for thread-safe shared state
        - Clone products before returning to release locks quickly
        - Implement proper error handling with Option types
        - Follow Rust naming conventions: snake_case for functions, PascalCase for types
        - Keep code clean, simple, and well-organized
        - Add appropriate derive macros: Debug, Serialize, Deserialize, Clone where needed

        THREAD SAFETY REQUIREMENTS:
        - ProductService must be safely shareable across threads
        - Use Arc for shared ownership, Mutex for exclusive access
        - Acquire locks, perform operation, clone result, release lock
        - Never hold a lock while doing expensive operations
        - The service will be used as web::Data in actix-web (requires Send + Sync)

        FILTERING IMPLEMENTATION:
        - Support four filter types: name_contains, min_price, max_price, in_stock
        - All filters are optional (Option&lt;T&gt;)
        - Apply all filters with AND logic
        - name_contains: case-insensitive partial match using to_lowercase()
        - min_price: inclusive comparison (price &gt;= min_price)
        - max_price: inclusive comparison (price &lt;= max_price)
        - in_stock: true means inventory_count &gt; 0, false means inventory_count == 0
        - Return empty vector if no matches, not an error

        INTEGRATION POINTS:
        - Task 5 (Shopping Cart API) will use this module
        - Cart service will call get_by_id() to validate products
        - Cart service will check inventory_count before adding items
        - Product names and prices will be displayed in cart
        - Ensure ProductService can be instantiated and shared across handlers

        DEPENDENCY NOTES:
        - rust_decimal version must be 1.30 or higher
        - Must include "serde" feature for JSON serialization
        - serde and serde_json should already be in project dependencies
        - This is the only new dependency needed for this task

        SUCCESS DEFINITION:
        You have completed this task successfully when:
        1. All three files created: mod.rs, models.rs, service.rs
        2. All structs defined correctly with proper types
        3. ProductService has all six methods implemented
        4. Thread-safe storage using Arc&lt;Mutex&gt;
        5. Filter method implements all criteria correctly
        6. Cargo.toml updated with rust_decimal
        7. cargo check passes without errors or warnings
        8. Module is ready for Task 5 to import and use

        VALIDATION CHECKLIST:
        Before marking complete, verify:
        - [ ] Files exist: src/catalog/mod.rs, models.rs, service.rs
        - [ ] Product struct has id, name, description, price (Decimal), inventory_count
        - [ ] NewProduct struct has all fields except id
        - [ ] ProductFilter has all optional query fields
        - [ ] ProductService has products and next_id fields with Arc&lt;Mutex&gt;
        - [ ] All six methods implemented: new, create, get_all, get_by_id, update_inventory, filter
        - [ ] Filter uses case-insensitive name matching
        - [ ] Cargo.toml has rust_decimal with serde feature
        - [ ] cargo check passes successfully

        DO NOT:
        - Add extra features beyond specifications
        - Use f32 or f64 for prices
        - Implement database connections (use in-memory only)
        - Add unnecessary complexity
        - Skip validation steps
        - Mark complete if cargo check fails

        DO:
        - Follow exact specifications provided
        - Use rust_decimal for all monetary values
        - Implement thread-safe patterns correctly
        - Clone products before returning from methods
        - Validate implementation before marking complete
        - Keep code simple and maintainable
    </instructions>
</prompt>
