<?xml version="1.0" encoding="UTF-8"?>
<prompt>
    <role>You are a senior Rust security engineer specializing in authentication systems, JWT tokens, and cryptographic password hashing.</role>
    <task>
        <id>3</id>
        <title>User Authentication Module</title>
        <description>Create user authentication and JWT handling functionality with secure password hashing. Implement JWT token creation and validation using jsonwebtoken crate, user model with Argon2 password hashing, and authentication module structure for secure API access.</description>
        <priority>high</priority>
        <status>pending</status>
        <dependencies></dependencies>
        <level>0</level>
        <estimated_time>45 minutes</estimated_time>
    </task>
    <technical_specifications>
        <spec>Use jsonwebtoken 8.3.0 for JWT creation and validation with HS256 algorithm</spec>
        <spec>Implement JWT Claims with sub (user ID), exp (expiration), and iat (issued at) fields</spec>
        <spec>Set token expiration to 24 hours from creation time</spec>
        <spec>Use Argon2 0.5.0 for memory-hard password hashing resistant to GPU attacks</spec>
        <spec>Generate 32-byte cryptographically random salt per password using rand 0.8.5</spec>
        <spec>Implement User model with id, username, email, and password_hash fields</spec>
        <spec>Mark password_hash with #[serde(skip_serializing)] to prevent JSON exposure</spec>
        <spec>Implement verify_password with constant-time comparison via argon2 library</spec>
        <spec>Use test secret key b"test_secret_key" (document production requirement for env var)</spec>
    </technical_specifications>
    <implementation_details>
        <step>
            <number>1</number>
            <action>Create authentication module structure</action>
            <details>
                Create src/auth/mod.rs with module declarations and re-exports:

                pub mod jwt;
                pub mod models;

                pub use self::jwt::{create_token, validate_token};
                pub use self::models::User;

                This provides ergonomic imports for consumers: use crate::auth::{create_token, validate_token, User};
            </details>
        </step>
        <step>
            <number>2</number>
            <action>Implement JWT token creation and validation</action>
            <details>
                Create src/auth/jwt.rs with complete JWT functionality:

                1. Import required crates:
                   - jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey}
                   - serde::{Serialize, Deserialize}
                   - std::time::{SystemTime, UNIX_EPOCH}

                2. Define Claims struct:
                   - Derive Debug, Serialize, Deserialize
                   - Fields: sub (String for user ID), exp (usize for expiration timestamp), iat (usize for issued-at timestamp)
                   - Make all fields public for access

                3. Implement create_token function:
                   - Parameter: user_id: &amp;str
                   - Return: Result&lt;String, jsonwebtoken::errors::Error&gt;
                   - Calculate expiration: current_time + 24 hours (24 * 3600 seconds)
                   - Calculate issued_at: current_time
                   - Create Claims with user_id, expiration, and issued_at
                   - Use secret key b"test_secret_key"
                   - Encode with Header::default() (HS256 algorithm)
                   - Return encoded JWT string

                4. Implement validate_token function:
                   - Parameter: token: &amp;str
                   - Return: Result&lt;Claims, jsonwebtoken::errors::Error&gt;
                   - Use same secret key b"test_secret_key"
                   - Create Validation::default() (validates expiration automatically)
                   - Decode token and extract claims
                   - Return Claims on success, error on failure

                Security notes:
                - Add comment: "In a real app, this would be a proper secret key from environment"
                - Token automatically expires after 24 hours
                - jsonwebtoken crate handles expiration checking
            </details>
        </step>
        <step>
            <number>3</number>
            <action>Implement User model with secure password hashing</action>
            <details>
                Create src/auth/models.rs with User struct and password handling:

                1. Import required crates:
                   - serde::{Serialize, Deserialize}
                   - argon2::{self, Config}
                   - rand::Rng

                2. Define User struct:
                   - Derive Debug, Serialize, Deserialize
                   - Fields: id (i32), username (String), email (String), password_hash (String)
                   - Mark password_hash with #[serde(skip_serializing)] attribute
                   - Make all fields public

                3. Implement User methods:

                   a) verify_password(&amp;self, password: &amp;str) -&gt; bool:
                      - Call argon2::verify_encoded(&amp;self.password_hash, password.as_bytes())
                      - Use unwrap_or(false) to return false on any error
                      - Returns true if password matches, false otherwise
                      - Constant-time comparison via argon2 library

                   b) hash_password(password: &amp;str) -&gt; String:
                      - Generate 32-byte random salt: rand::thread_rng().gen::&lt;[u8; 32]&gt;()
                      - Create Config::default() for secure Argon2 parameters
                      - Call argon2::hash_encoded(password.as_bytes(), &amp;salt, &amp;config)
                      - unwrap() is acceptable here (hashing rarely fails with valid inputs)
                      - Return encoded hash string in PHC format

                Security features:
                - Argon2 is memory-hard (resistant to GPU/ASIC attacks)
                - Random salt prevents rainbow table attacks
                - Each hash call produces different output (unique salt)
                - password_hash never appears in JSON output
                - Constant-time comparison prevents timing attacks
            </details>
        </step>
        <step>
            <number>4</number>
            <action>Update Cargo.toml dependencies</action>
            <details>
                Add authentication and cryptography dependencies to [dependencies] section:

                jsonwebtoken = "8.3.0"
                argon2 = "0.5.0"
                rand = "0.8.5"

                Dependency rationale:
                - jsonwebtoken: Industry-standard JWT implementation for Rust
                - argon2: Winner of Password Hashing Competition, OWASP recommended
                - rand: Cryptographically secure random number generation

                These dependencies provide secure, well-audited cryptographic primitives.
            </details>
        </step>
        <step>
            <number>5</number>
            <action>Validate implementation</action>
            <details>
                Run comprehensive validation checks:

                1. File structure:
                   ls -la src/auth/mod.rs src/auth/jwt.rs src/auth/models.rs

                2. Compilation:
                   cargo check
                   Must compile without errors

                3. Dependencies:
                   grep -E "jsonwebtoken|argon2|rand" Cargo.toml
                   All three dependencies must be present

                4. JWT test (if possible):
                   - Create token for test user
                   - Validate token and extract claims
                   - Verify user ID matches

                5. Password test (if possible):
                   - Hash same password twice
                   - Verify both hashes are different
                   - Verify both verify successfully

                6. Serialization test (if possible):
                   - Serialize User to JSON
                   - Confirm password_hash is NOT in output

                Do not mark complete if any validation fails.
            </details>
        </step>
    </implementation_details>
    <acceptance_criteria>
        <criterion>src/auth/mod.rs exists with pub mod declarations for jwt and models, and re-exports for create_token, validate_token, and User</criterion>
        <criterion>src/auth/jwt.rs exists with Claims struct (sub, exp, iat fields) deriving Debug, Serialize, Deserialize</criterion>
        <criterion>create_token function implemented returning Result with JWT string, using 24-hour expiration</criterion>
        <criterion>validate_token function implemented returning Result with Claims, properly decoding and validating tokens</criterion>
        <criterion>src/auth/models.rs exists with User struct (id, username, email, password_hash) deriving Debug, Serialize, Deserialize</criterion>
        <criterion>User password_hash field marked with #[serde(skip_serializing)] to prevent JSON exposure</criterion>
        <criterion>verify_password method implemented using argon2::verify_encoded with unwrap_or(false)</criterion>
        <criterion>hash_password static method implemented with 32-byte random salt and Argon2 Config::default()</criterion>
        <criterion>Cargo.toml includes jsonwebtoken 8.3.0, argon2 0.5.0, and rand 0.8.5 dependencies</criterion>
        <criterion>Code compiles with 'cargo check' without errors or warnings</criterion>
        <criterion>JWT tokens include all required claims (sub, exp, iat)</criterion>
        <criterion>Same password produces different hashes due to random salts</criterion>
        <criterion>Password verification uses constant-time comparison via argon2</criterion>
    </acceptance_criteria>
    <test_strategy>
        Comprehensive validation approach for authentication implementation:

        1. Compilation Testing:
           cargo check
           - Verify syntax correctness
           - Ensure all imports resolve
           - Validate no compilation errors

        2. Module Structure Verification:
           ls -la src/auth/
           - Confirm all files created
           - Check directory structure

        3. Dependency Validation:
           grep jsonwebtoken Cargo.toml
           grep argon2 Cargo.toml
           grep rand Cargo.toml
           - Ensure all dependencies present
           - Verify correct versions

        4. JWT Functionality Tests:
           #[test]
           fn test_jwt_lifecycle() {
               let token = create_token("123").unwrap();
               let claims = validate_token(&amp;token).unwrap();
               assert_eq!(claims.sub, "123");
               assert!(claims.exp &gt; claims.iat);
           }
           - Token creation succeeds
           - Token validation succeeds
           - Claims extracted correctly
           - Expiration is in the future

        5. Password Hashing Tests:
           #[test]
           fn test_password_hashing() {
               let pwd = "test";
               let hash1 = User::hash_password(pwd);
               let hash2 = User::hash_password(pwd);
               assert_ne!(hash1, hash2);  // Different salts
               assert!(argon2::verify_encoded(&amp;hash1, pwd.as_bytes()).unwrap());
           }
           - Same password produces different hashes
           - Hashes verify successfully
           - Argon2 format is correct

        6. User Verification Tests:
           #[test]
           fn test_user_password_verification() {
               let hash = User::hash_password("correct");
               let user = User { password_hash: hash, ... };
               assert!(user.verify_password("correct"));
               assert!(!user.verify_password("wrong"));
           }
           - Correct password returns true
           - Wrong password returns false
           - No panics on invalid input

        7. Serialization Security Tests:
           #[test]
           fn test_password_not_serialized() {
               let user = User { password_hash: "secret".into(), ... };
               let json = serde_json::to_string(&amp;user).unwrap();
               assert!(!json.contains("password_hash"));
               assert!(!json.contains("secret"));
           }
           - User serializes successfully
           - password_hash field excluded
           - No password data in JSON

        8. Security Validation:
           - Verify Argon2 is used (memory-hard)
           - Confirm random salt generation
           - Check constant-time comparison
           - Validate JWT expiration
           - Ensure no plain-text passwords

        9. Integration Readiness:
           - Functions publicly accessible
           - Ready for Task 5 cart authentication
           - Testable by Task 7 integration tests
    </test_strategy>
    <instructions>
        You are implementing Task 3: User Authentication Module for a parallel task execution test project.

        CRITICAL INSTRUCTIONS:
        - This is a Level 0 task with NO dependencies - proceed immediately
        - Create exactly three files: src/auth/mod.rs, src/auth/jwt.rs, src/auth/models.rs
        - Update Cargo.toml with authentication dependencies
        - This is a test project but MUST use production-grade cryptography

        SECURITY REQUIREMENTS:
        - Use Argon2 for password hashing (memory-hard, OWASP recommended)
        - Generate unique random 32-byte salt per password
        - Never serialize password_hash to JSON
        - Set JWT expiration to 24 hours
        - Use constant-time password comparison
        - Proper error handling in all crypto operations

        IMPLEMENTATION APPROACH:
        1. Start with module structure (mod.rs)
        2. Implement JWT functionality (jwt.rs)
        3. Implement User model (models.rs)
        4. Add dependencies (Cargo.toml)
        5. Validate cryptographic correctness

        JWT IMPLEMENTATION:
        - Claims: sub (user ID), exp (expiration), iat (issued at)
        - Algorithm: HS256 (HMAC-SHA256)
        - Expiration: 24 hours from creation
        - Secret: b"test_secret_key" (comment as test-only)
        - Return Result types for proper error handling

        PASSWORD SECURITY:
        - Hash: Argon2 with Config::default()
        - Salt: 32 random bytes via rand::thread_rng()
        - Verification: argon2::verify_encoded (constant-time)
        - Serialization: #[serde(skip_serializing)] on password_hash
        - Different hashes for same password (unique salts)

        USER MODEL:
        - Fields: id (i32), username (String), email (String), password_hash (String)
        - Derive: Debug, Serialize, Deserialize
        - Methods: verify_password (instance), hash_password (static)
        - password_hash must NEVER appear in JSON output

        CRYPTOGRAPHIC BEST PRACTICES:
        - Use established libraries (jsonwebtoken, argon2, rand)
        - No custom crypto implementations
        - Proper error handling (Result types)
        - No timing side-channels
        - Secure defaults (Config::default() is secure)

        TEST LIMITATIONS (Acceptable for this project):
        - Hardcoded JWT secret (document production requirement)
        - No token refresh mechanism
        - No token revocation
        - Basic claims structure
        - No rate limiting

        VALIDATION REQUIREMENTS:
        1. cargo check must pass
        2. JWT creation and validation must work
        3. Same password must produce different hashes
        4. Password verification must work correctly
        5. password_hash must NOT serialize to JSON
        6. All security best practices followed

        QUALITY STANDARDS:
        - Follow Rust naming conventions
        - Proper use of Result types
        - Clear error handling
        - No unwrap() in library code (except hash_password where justified)
        - Code properly formatted

        INTEGRATION POINTS:
        - Task 5 (Shopping Cart) will use validate_token for authentication
        - Task 7 (Integration Tests) will test authentication flow
        - Functions must be publicly accessible via mod.rs

        SUCCESS DEFINITION:
        You have completed this task successfully when:
        1. All required files created with correct implementations
        2. cargo check passes without errors
        3. JWT tokens can be created and validated
        4. Passwords can be hashed and verified
        5. password_hash excluded from JSON serialization
        6. Industry-standard cryptographic practices followed
        7. Ready for use by Task 5 and testing by Task 7

        DO NOT:
        - Use weak hashing algorithms (MD5, SHA-1, SHA-256 without salt)
        - Store passwords in plain text
        - Include password_hash in JSON output
        - Skip error handling in crypto operations
        - Use custom crypto instead of established libraries
        - Reuse salts across passwords

        DO:
        - Use Argon2 for password hashing
        - Generate unique random salt per password
        - Mark password_hash with #[serde(skip_serializing)]
        - Set JWT expiration
        - Use Result types for error handling
        - Comment test-only limitations
        - Follow security best practices
        - Validate thoroughly before completing
    </instructions>
</prompt>
