<?xml version="1.0" encoding="UTF-8"?>
<prompt>
    <role>You are a senior Rust backend developer specializing in web services with Actix-web framework.</role>

    <task>
        <id>2</id>
        <title>API Endpoints</title>
        <description>Create REST API endpoints for core operations of the application using Actix-web. Set up the HTTP server, implement modular routing structure, create a health check endpoint, and define placeholder route configurations for users and products that will be implemented by subsequent tasks.</description>
        <priority>high</priority>
        <status>pending</status>
        <dependencies>1</dependencies>
        <level>1</level>
        <estimated_time>50 minutes</estimated_time>
    </task>

    <technical_specifications>
        <spec>Use Actix-web 4.3.1 as the web framework</spec>
        <spec>Implement async HTTP server bound to 127.0.0.1:8080</spec>
        <spec>Use Serde 1.0 with derive feature for serialization</spec>
        <spec>Use serde_json 1.0 for JSON responses</spec>
        <spec>Create modular routing with /api base scope</spec>
        <spec>Implement health check endpoint at /api/health</spec>
        <spec>Create nested scopes for /users and /products</spec>
        <spec>Use ServiceConfig pattern for route configuration</spec>
        <spec>Import schema module from Task 1 to validate dependency</spec>
    </technical_specifications>

    <implementation_details>
        <overview>This task establishes the HTTP server and routing infrastructure. It is a Level 1 task that depends on Task 1 (Database Schema) and provides the foundation for authentication, catalog, and cart modules.</overview>

        <step number="1">
            <action>Update Cargo.toml with web framework dependencies</action>
            <details>
                Add to [dependencies] section (Task 1 added database deps):
                - actix-web = "4.3.1"
                - serde = { version = "1.0", features = ["derive"] }
                - serde_json = "1.0"

                Ensure no conflicts with existing dependencies from Task 1.
            </details>
        </step>

        <step number="2">
            <action>Create src/api/mod.rs</action>
            <details>
                Simple module export file:
                pub mod routes;

                This establishes the API module namespace.
            </details>
        </step>

        <step number="3">
            <action>Create src/api/routes.rs with routing logic</action>
            <details>
                Import required types:
                - use actix_web::{web, HttpResponse, Scope};
                - use crate::schema;

                Implement configure_routes function:
                - Accept &amp;mut web::ServiceConfig parameter
                - Create /api scope
                - Register health_check handler
                - Add nested /users scope with user_routes configuration
                - Add nested /products scope with product_routes configuration

                Implement health_check handler:
                - Use #[actix_web::get("/health")] attribute
                - Return HttpResponse::Ok().json(serde_json::json!({"status": "ok"}))

                Implement user_routes placeholder:
                - Accept &amp;mut web::ServiceConfig parameter
                - Register empty resource returning NotImplemented

                Implement product_routes placeholder:
                - Accept &amp;mut web::ServiceConfig parameter
                - Register empty resource returning NotImplemented
            </details>
        </step>

        <step number="4">
            <action>Create src/main.rs application entry point</action>
            <details>
                Import required types:
                - use actix_web::{App, HttpServer};

                Declare modules:
                - mod api;
                - mod schema;

                Implement main function:
                - Use #[actix_web::main] attribute
                - Signature: async fn main() -&gt; std::io::Result&lt;()&gt;
                - Print startup message
                - Create HttpServer with app factory
                - App factory: App::new().configure(api::routes::configure_routes)
                - Bind to "127.0.0.1:8080"
                - Call .run().await
            </details>
        </step>

        <step number="5">
            <action>Verify compilation and dependencies</action>
            <details>
                Run cargo check to verify compilation
                Run cargo tree to verify dependencies
                Ensure schema import resolves (Task 1 complete)
                Verify no dependency conflicts
            </details>
        </step>

        <step number="6">
            <action>Test server startup and endpoints</action>
            <details>
                Run cargo run to start server
                Test health endpoint: curl http://localhost:8080/api/health
                Verify JSON response: {"status":"ok"}
                Test placeholder routes return 501 Not Implemented
                Verify server binds successfully to port 8080
            </details>
        </step>
    </implementation_details>

    <acceptance_criteria>
        <criterion>Files src/api/mod.rs and src/api/routes.rs exist with correct implementations</criterion>
        <criterion>File src/main.rs exists with server startup logic</criterion>
        <criterion>Cargo.toml includes actix-web, serde, and serde_json dependencies</criterion>
        <criterion>Server compiles without errors (cargo check passes)</criterion>
        <criterion>Server starts and binds to 127.0.0.1:8080</criterion>
        <criterion>Health check endpoint /api/health returns HTTP 200 with JSON {"status":"ok"}</criterion>
        <criterion>User placeholder at /api/users returns HTTP 501 Not Implemented</criterion>
        <criterion>Product placeholder at /api/products returns HTTP 501 Not Implemented</criterion>
        <criterion>Schema module from Task 1 imports successfully</criterion>
        <criterion>No dependency conflicts with Task 1's database dependencies</criterion>
        <criterion>Routes use modular ServiceConfig pattern for extensibility</criterion>
    </acceptance_criteria>

    <test_strategy>
        <validation>
            Manual validation steps:

            1. Verify file existence:
               - ls -la src/api/mod.rs
               - ls -la src/api/routes.rs
               - ls -la src/main.rs

            2. Check compilation:
               - cargo check
               - cargo build

            3. Validate dependencies:
               - cargo tree | grep actix-web
               - cargo tree | grep serde

            4. Start server:
               - cargo run &amp;
               - sleep 2

            5. Test health endpoint:
               - curl -i http://localhost:8080/api/health
               - Expected: HTTP 200, JSON body {"status":"ok"}

            6. Test placeholder routes:
               - curl -i http://localhost:8080/api/users
               - Expected: HTTP 501 Not Implemented
               - curl -i http://localhost:8080/api/products
               - Expected: HTTP 501 Not Implemented

            7. Stop server:
               - pkill -f "cargo run"
        </validation>

        <integration_testing>
            This task enables:
            - Task 3 to implement user authentication routes
            - Task 4 to implement product catalog routes
            - Task 5 to add shopping cart routes
            - Task 7 to test all API endpoints

            Depends on:
            - Task 1 for schema module import
        </integration_testing>

        <automated_test>
            Create test script to verify:
            - Server builds successfully
            - Server starts and binds to port
            - Health endpoint returns correct response
            - Placeholder routes return 501 status
            - Server shuts down cleanly
        </automated_test>
    </test_strategy>

    <instructions>
        Think step-by-step and follow the implementation plan exactly.

        1. Update Cargo.toml first with web framework dependencies
        2. Create the API module structure (mod.rs and routes.rs)
        3. Implement routing with proper scope nesting
        4. Create health check handler with JSON response
        5. Add placeholder routes for users and products
        6. Set up main.rs with server configuration
        7. Verify compilation with schema import from Task 1
        8. Test server startup and endpoint responses

        Use standard Actix-web patterns and async/await syntax.
        Include proper imports and error handling.
        Ensure placeholder routes are clearly marked for future implementation.

        Remember: You depend on Task 1 (Database Schema) completing first.
        Your schema import validates this dependency.
        Keep implementations simple - this is a test project.

        Task 3, 4, and 5 will extend your routing structure.
        Task 7 will test your endpoints.

        This is a Level 1 task - you can start after Task 1 completes.
    </instructions>

    <context>
        <project>
            <name>Parallel Task Execution Test</name>
            <repository>https://github.com/5dlabs/cto-parallel-test</repository>
            <purpose>Testing parallel task orchestration, dependency management, and conflict detection</purpose>
        </project>

        <architecture>
            <component>Web Server Layer</component>
            <technology>Rust + Actix-web</technology>
            <pattern>Modular routing with scope-based organization</pattern>
            <integration>Connects to database layer (Task 1) and enables feature modules (Tasks 3-5)</integration>
        </architecture>

        <execution_context>
            <level>1</level>
            <depends_on>Task 1 (Database Schema)</depends_on>
            <enables>Tasks 3, 4, 5, 7</enables>
            <parallel_with>Task 5 (Shopping Cart) at Level 1</parallel_with>
        </execution_context>

        <constraints>
            <constraint>Must successfully import schema module from Task 1</constraint>
            <constraint>Cargo.toml also modified by Task 1 - ensure no conflicts</constraint>
            <constraint>Port 8080 must be available for testing</constraint>
            <constraint>Keep implementations simple for testing purposes</constraint>
        </constraints>
    </context>
</prompt>
