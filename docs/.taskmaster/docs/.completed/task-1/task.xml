<?xml version="1.0" encoding="UTF-8"?>
<prompt>
    <role>You are a senior Rust backend developer specializing in database design with Diesel ORM and PostgreSQL.</role>

    <task>
        <id>1</id>
        <title>Database Schema Setup</title>
        <description>Create basic database schema files and configuration for the Rust API project using Diesel ORM. This includes defining table schemas for users, products, carts, and cart items, along with initial migration files and dependency configuration.</description>
        <priority>high</priority>
        <status>pending</status>
        <dependencies></dependencies>
        <level>0</level>
        <estimated_time>30 minutes</estimated_time>
    </task>

    <technical_specifications>
        <spec>Use Diesel ORM version 2.1.0 with PostgreSQL and r2d2 connection pooling</spec>
        <spec>Define schema using Diesel's table! macro with proper column types</spec>
        <spec>Create four tables: users, products, carts, cart_items</spec>
        <spec>Implement foreign key relationships and constraints</spec>
        <spec>Use r2d2 0.8.10 for connection pooling</spec>
        <spec>Use dotenv 0.15.0 for configuration management</spec>
        <spec>Create migration files with up.sql and down.sql</spec>
        <spec>Ensure referential integrity with CASCADE deletes where appropriate</spec>
    </technical_specifications>

    <implementation_details>
        <overview>This task establishes the data layer foundation for the e-commerce test API. It is a Level 0 task that runs independently in parallel with Tasks 3, 4, and 6.</overview>

        <step number="1">
            <action>Update Cargo.toml with database dependencies</action>
            <details>
                Add to [dependencies] section:
                - diesel = { version = "2.1.0", features = ["postgres", "r2d2"] }
                - r2d2 = "0.8.10"
                - dotenv = "0.15.0"
            </details>
        </step>

        <step number="2">
            <action>Create src/schema.rs with table definitions</action>
            <details>
                Define four tables using table! macro:

                users (id) with columns:
                - id -> Integer (primary key)
                - username -> Varchar
                - email -> Varchar
                - password_hash -> Varchar
                - created_at -> Timestamp

                products (id) with columns:
                - id -> Integer (primary key)
                - name -> Varchar
                - description -> Text
                - price -> Numeric
                - inventory_count -> Integer

                carts (id) with columns:
                - id -> Integer (primary key)
                - user_id -> Integer
                - created_at -> Timestamp

                cart_items (id) with columns:
                - id -> Integer (primary key)
                - cart_id -> Integer
                - product_id -> Integer
                - quantity -> Integer
            </details>
        </step>

        <step number="3">
            <action>Create migrations directory structure</action>
            <details>
                Create: migrations/00000000000001_create_tables/
                This directory will contain up.sql and down.sql
            </details>
        </step>

        <step number="4">
            <action>Write migrations/00000000000001_create_tables/up.sql</action>
            <details>
                Include CREATE TABLE statements for all four tables with:
                - SERIAL PRIMARY KEY for id columns
                - NOT NULL constraints on required fields
                - UNIQUE constraints on users.username and users.email
                - FOREIGN KEY constraints:
                  * carts.user_id REFERENCES users(id)
                  * cart_items.cart_id REFERENCES carts(id) ON DELETE CASCADE
                  * cart_items.product_id REFERENCES products(id)
                - UNIQUE constraint on cart_items(cart_id, product_id)
                - DEFAULT CURRENT_TIMESTAMP for created_at columns
                - DEFAULT 0 for inventory_count
            </details>
        </step>

        <step number="5">
            <action>Write migrations/00000000000001_create_tables/down.sql</action>
            <details>
                Include DROP TABLE IF EXISTS statements in reverse order:
                1. cart_items (has foreign keys to carts and products)
                2. carts (has foreign key to users)
                3. products
                4. users
            </details>
        </step>

        <step number="6">
            <action>Verify compilation</action>
            <details>
                Run: cargo check
                Ensure no syntax errors in schema.rs
                Confirm dependencies resolve correctly
            </details>
        </step>
    </implementation_details>

    <acceptance_criteria>
        <criterion>File src/schema.rs exists and contains valid Diesel table definitions for all four tables</criterion>
        <criterion>Migration directory exists: migrations/00000000000001_create_tables/</criterion>
        <criterion>Migration up.sql contains valid PostgreSQL CREATE TABLE statements with all constraints</criterion>
        <criterion>Migration down.sql contains valid DROP TABLE statements in correct order</criterion>
        <criterion>Cargo.toml includes all three required dependencies with correct versions and features</criterion>
        <criterion>cargo check completes without errors</criterion>
        <criterion>Schema definitions use correct Diesel column types</criterion>
        <criterion>Foreign key relationships are properly defined in SQL</criterion>
        <criterion>All tables specify primary keys correctly</criterion>
        <criterion>UNIQUE constraints are applied to users.username, users.email, and cart_items(cart_id, product_id)</criterion>
    </acceptance_criteria>

    <test_strategy>
        <validation>
            Manual validation steps:

            1. Verify file existence:
               - ls -la src/schema.rs
               - ls -la migrations/

            2. Check Rust compilation:
               - cargo check

            3. Validate dependencies:
               - cargo tree | grep diesel
               - cargo tree | grep r2d2
               - cargo tree | grep dotenv

            4. Syntax check SQL files:
               - cat migrations/*/up.sql
               - cat migrations/*/down.sql

            5. Verify schema structure:
               - grep -c "table!" src/schema.rs  (should output: 4)

            Expected outcomes:
            - All commands complete without errors
            - Files contain expected content
            - Dependencies resolve correctly
            - SQL syntax is valid PostgreSQL
        </validation>

        <integration_testing>
            This task enables:
            - Task 2 to import and use schema definitions in API endpoints
            - Task 3 to work with users table for authentication
            - Task 4 to work with products table for catalog
            - Task 5 to work with carts tables for shopping cart functionality
        </integration_testing>
    </test_strategy>

    <instructions>
        Think step-by-step and follow the implementation plan exactly.

        1. Start by updating Cargo.toml with the exact dependencies specified
        2. Create src/schema.rs with all four table definitions using proper Diesel syntax
        3. Create the migrations directory and migration files
        4. Write complete SQL in up.sql with all constraints and relationships
        5. Write corresponding DROP statements in down.sql
        6. Verify everything compiles with cargo check

        Use standard Diesel patterns and conventions. Include all necessary imports.
        Ensure proper error handling is possible (though this is a test/placeholder implementation).

        Remember: Task 2 will also modify Cargo.toml, so use standard formatting.
        Keep implementations simple and focused on correct file structure.

        This is a Level 0 task with no dependencies - you can start immediately.
        Other Level 0 tasks (3, 4, 6) are running in parallel.
        Task 2 depends on your completion.
    </instructions>

    <context>
        <project>
            <name>Parallel Task Execution Test</name>
            <repository>https://github.com/5dlabs/cto-parallel-test</repository>
            <purpose>Testing parallel task orchestration, dependency management, and conflict detection</purpose>
        </project>

        <architecture>
            <component>Database Layer</component>
            <technology>Rust + Diesel ORM + PostgreSQL</technology>
            <pattern>Repository pattern with ORM abstraction</pattern>
        </architecture>

        <constraints>
            <constraint>This is a test project - focus on structure over production quality</constraint>
            <constraint>File modifications may conflict with other parallel tasks</constraint>
            <constraint>Simple, clear implementations preferred over complex patterns</constraint>
        </constraints>
    </context>
</prompt>
