<?xml version="1.0" encoding="UTF-8"?>
<prompt>
    <role>You are a senior Rust backend developer and database architect specializing in Diesel ORM, PostgreSQL, and e-commerce system design.</role>

    <task>
        <id>1</id>
        <title>Database Schema Setup</title>
        <description>Create basic database schema files and configuration for the Rust API project using Diesel ORM with PostgreSQL. Establish the foundational data layer for an e-commerce application with users, products, carts, and cart items.</description>
        <priority>high</priority>
        <status>pending</status>
        <dependencies></dependencies>
        <execution_level>0</execution_level>
        <parallel_execution>true</parallel_execution>
        <estimated_duration>30 minutes</estimated_duration>
    </task>

    <technical_specifications>
        <spec>Use Diesel ORM version 2.1.0 with PostgreSQL, r2d2, and chrono features</spec>
        <spec>Implement connection pooling using r2d2 version 0.8.10</spec>
        <spec>Create 4 database tables: users, products, carts, cart_items</spec>
        <spec>Define foreign key relationships: carts references users, cart_items references carts and products</spec>
        <spec>Use chrono::NaiveDateTime for timestamp fields</spec>
        <spec>Implement both Queryable and Insertable model structs for each table</spec>
        <spec>Store passwords as password_hash, never plaintext</spec>
        <spec>Enforce unique constraints on username and email fields</spec>
        <spec>Use dotenv for environment variable management</spec>
        <spec>Configure DATABASE_URL via .env file</spec>
    </technical_specifications>

    <implementation_details>
        <section name="Dependencies">
            Add to Cargo.toml:
            - diesel = { version = "2.1.0", features = ["postgres", "r2d2", "chrono"] }
            - r2d2 = "0.8.10"
            - dotenv = "0.15.0"
            - chrono = { version = "0.4", features = ["serde"] }
            - serde = { version = "1.0", features = ["derive"] }
            - serde_json = "1.0"
        </section>

        <section name="Database Configuration">
            Create src/config/db.rs with:
            - Pool type alias for r2d2::Pool&lt;ConnectionManager&lt;PgConnection&gt;&gt;
            - DbConnection type alias for pooled connection
            - establish_connection_pool() function that reads DATABASE_URL and creates pool
            - Proper error handling with descriptive panic messages
        </section>

        <section name="Schema Definitions">
            Create src/schema.rs with table! macros for:
            1. users (id, username, email, password_hash, created_at)
            2. products (id, name, description, price, inventory_count)
            3. carts (id, user_id FK, created_at)
            4. cart_items (id, cart_id FK, product_id FK, quantity)

            Include:
            - joinable! macros for foreign key relationships
            - allow_tables_to_appear_in_same_query! for all tables
        </section>

        <section name="Database Migrations">
            Create migration pairs (up.sql/down.sql) for each table:

            1. create_users:
               - up.sql: CREATE TABLE with SERIAL PRIMARY KEY, UNIQUE constraints
               - down.sql: DROP TABLE users

            2. create_products:
               - up.sql: CREATE TABLE with price as NUMERIC, inventory_count as INTEGER
               - down.sql: DROP TABLE products

            3. create_carts:
               - up.sql: CREATE TABLE with FOREIGN KEY REFERENCES users(id)
               - down.sql: DROP TABLE carts

            4. create_cart_items:
               - up.sql: CREATE TABLE with FOREIGN KEYS to carts and products
               - down.sql: DROP TABLE cart_items
        </section>

        <section name="Model Structs">
            Create src/models.rs with structs for each table:

            Queryable structs (for reading):
            - User: id, username, email, password_hash, created_at
            - Product: id, name, description, price, inventory_count
            - Cart: id, user_id, created_at
            - CartItem: id, cart_id, product_id, quantity

            Insertable structs (for writing):
            - NewUser: username, email, password_hash
            - NewProduct: name, description, price, inventory_count
            - NewCart: user_id
            - NewCartItem: cart_id, product_id, quantity

            Apply appropriate derives:
            - Queryable, Identifiable, Serialize, Deserialize for read structs
            - Insertable, Deserialize for insert structs
            - Associations where foreign keys exist
        </section>

        <section name="Module Structure">
            Update src/lib.rs or src/main.rs:
            - pub mod config;
            - pub mod models;
            - pub mod schema;

            Create src/config/mod.rs:
            - pub mod db;
        </section>

        <section name="Environment Setup">
            Create .env file in project root:
            - DATABASE_URL=postgres://username:password@localhost/database_name

            Ensure .env is in .gitignore or provide .env.example
        </section>
    </implementation_details>

    <acceptance_criteria>
        <criterion>All dependencies added to Cargo.toml and resolve successfully</criterion>
        <criterion>cargo build completes without errors</criterion>
        <criterion>cargo check passes with zero warnings</criterion>
        <criterion>Database configuration module (src/config/db.rs) created with connection pool function</criterion>
        <criterion>Schema definitions (src/schema.rs) compile without errors</criterion>
        <criterion>Four migration pairs created for users, products, carts, and cart_items</criterion>
        <criterion>diesel migration run applies all migrations successfully</criterion>
        <criterion>diesel migration redo rolls back and reapplies migrations successfully</criterion>
        <criterion>Eight model structs created (4 Queryable + 4 Insertable) in src/models.rs</criterion>
        <criterion>All model structs have correct derives and field types matching schema</criterion>
        <criterion>Foreign key relationships properly defined with joinable! macros</criterion>
        <criterion>Unique constraints on username and email enforced in migrations</criterion>
        <criterion>.env file created with DATABASE_URL example</criterion>
        <criterion>Module exports configured in src/lib.rs or src/main.rs</criterion>
        <criterion>Connection pool can be initialized without errors when DATABASE_URL is valid</criterion>
    </acceptance_criteria>

    <test_strategy>
        <test>Run cargo build to verify all dependencies resolve</test>
        <test>Run cargo check to ensure code compiles without warnings</test>
        <test>Install Diesel CLI: cargo install diesel_cli --no-default-features --features postgres</test>
        <test>Run diesel setup to initialize migrations directory</test>
        <test>Run diesel migration run to apply all migrations</test>
        <test>Run diesel migration redo to test rollback functionality</test>
        <test>Run diesel print-schema to verify schema structure</test>
        <test>Create simple unit test that initializes connection pool with valid DATABASE_URL</test>
        <test>Run cargo test to verify connection pool test passes</test>
        <test>Run cargo clippy to check for common mistakes</test>
        <test>Verify src/schema.rs matches database schema</test>
        <test>Verify model structs can serialize and deserialize correctly</test>
    </test_strategy>

    <instructions>
        You are implementing the database foundation for an e-commerce API. Think step-by-step and follow this sequence:

        1. Start by updating Cargo.toml with all required dependencies
        2. Create the src/config directory and implement db.rs with connection pooling
        3. Install Diesel CLI and run diesel setup to initialize migrations
        4. Generate four migrations in order: users, products, carts, cart_items
        5. Implement up.sql for each migration with proper constraints and foreign keys
        6. Implement down.sql for each migration to enable rollback
        7. Run diesel migration run to apply migrations and generate schema.rs
        8. Review and enhance schema.rs with joinable! and allow_tables_to_appear_in_same_query! macros
        9. Create src/models.rs with all Queryable and Insertable structs
        10. Update module exports in src/lib.rs or src/main.rs
        11. Create .env file with DATABASE_URL example
        12. Run cargo check to verify everything compiles
        13. Test migrations with diesel migration redo
        14. Create a simple test to verify connection pool functionality

        Follow Rust best practices:
        - Use snake_case for field names and function names
        - Use PascalCase for struct names
        - Include proper error handling with descriptive messages
        - Add documentation comments where helpful
        - Ensure all structs derive necessary traits
        - Use type aliases for complex types

        Pay special attention to:
        - Foreign key relationships must be defined in correct order (users before carts, carts/products before cart_items)
        - Migrations must be idempotent where possible
        - Password fields must always be password_hash, never password
        - Timestamp fields should use chrono::NaiveDateTime
        - Numeric types (price) should use appropriate precision

        This task has no dependencies and can run in parallel with Tasks 3, 4, and 6. Task 2 (API Endpoints) depends on this task being complete.

        Upon completion, verify all acceptance criteria are met and provide a summary of:
        - Number of migration files created
        - Result of cargo check
        - Result of diesel migration run
        - Any issues encountered and how they were resolved
        - Location of all created files
    </instructions>
</prompt>
