# Task ID: 4
# Title: Product Catalog Module
# Status: pending
# Dependencies: None
# Priority: medium
# Description: Create product catalog and inventory management functionality.
# Details:
Implement the product catalog module with inventory management:

1. Create `src/catalog/mod.rs` to export the catalog module components:
```rust
pub mod models;
pub mod service;

pub use self::models::Product;
pub use self::service::ProductService;
```

2. Create `src/catalog/models.rs` for product models:
```rust
use serde::{Serialize, Deserialize};
use rust_decimal::Decimal;

#[derive(Debug, Serialize, Deserialize)]
pub struct Product {
    pub id: i32,
    pub name: String,
    pub description: String,
    pub price: Decimal,
    pub inventory_count: i32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NewProduct {
    pub name: String,
    pub description: String,
    pub price: Decimal,
    pub inventory_count: i32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ProductFilter {
    pub name_contains: Option<String>,
    pub min_price: Option<Decimal>,
    pub max_price: Option<Decimal>,
    pub in_stock: Option<bool>,
}
```

3. Create `src/catalog/service.rs` for product service logic:
```rust
use crate::catalog::models::{Product, NewProduct, ProductFilter};
use rust_decimal::Decimal;
use std::sync::{Arc, Mutex};

// In a real app, this would interact with the database
pub struct ProductService {
    products: Arc<Mutex<Vec<Product>>>,
    next_id: Arc<Mutex<i32>>,
}

impl ProductService {
    pub fn new() -> Self {
        ProductService {
            products: Arc::new(Mutex::new(Vec::new())),
            next_id: Arc::new(Mutex::new(1)),
        }
    }
    
    pub fn create(&self, new_product: NewProduct) -> Product {
        let mut products = self.products.lock().unwrap();
        let mut next_id = self.next_id.lock().unwrap();
        
        let product = Product {
            id: *next_id,
            name: new_product.name,
            description: new_product.description,
            price: new_product.price,
            inventory_count: new_product.inventory_count,
        };
        
        *next_id += 1;
        products.push(product.clone());
        product
    }
    
    pub fn get_all(&self) -> Vec<Product> {
        let products = self.products.lock().unwrap();
        products.clone()
    }
    
    pub fn get_by_id(&self, id: i32) -> Option<Product> {
        let products = self.products.lock().unwrap();
        products.iter().find(|p| p.id == id).cloned()
    }
    
    pub fn update_inventory(&self, id: i32, new_count: i32) -> Option<Product> {
        let mut products = self.products.lock().unwrap();
        if let Some(product) = products.iter_mut().find(|p| p.id == id) {
            product.inventory_count = new_count;
            Some(product.clone())
        } else {
            None
        }
    }
    
    pub fn filter(&self, filter: ProductFilter) -> Vec<Product> {
        let products = self.products.lock().unwrap();
        products
            .iter()
            .filter(|p| {
                let name_match = filter.name_contains
                    .as_ref()
                    .map_or(true, |name| p.name.to_lowercase().contains(&name.to_lowercase()));
                
                let min_price_match = filter.min_price
                    .as_ref()
                    .map_or(true, |min| p.price >= *min);
                
                let max_price_match = filter.max_price
                    .as_ref()
                    .map_or(true, |max| p.price <= *max);
                
                let in_stock_match = filter.in_stock
                    .map_or(true, |in_stock| (p.inventory_count > 0) == in_stock);
                
                name_match && min_price_match && max_price_match && in_stock_match
            })
            .cloned()
            .collect()
    }
}
```

4. Update `Cargo.toml` to add catalog dependencies:
```toml
[dependencies]
rust_decimal = { version = "1.30", features = ["serde"] }
```

# Test Strategy:
1. Verify that all required files are created: `src/catalog/mod.rs`, `src/catalog/models.rs`, and `src/catalog/service.rs`
2. Compile the code to ensure there are no syntax errors
3. Write unit tests to verify product creation, retrieval, and inventory management
4. Test the product filtering functionality with various filter combinations
5. Verify that the catalog dependencies in `Cargo.toml` are correctly specified and can be resolved
6. Check that the Product models can be serialized and deserialized correctly

# Subtasks:
## 1. Create Product Catalog Module Structure [pending]
### Dependencies: None
### Description: Set up the basic module structure for the product catalog by creating the mod.rs file that exports the module components.
### Details:
Create the file `src/catalog/mod.rs` with the provided code to export the catalog module components. This file will serve as the entry point for the catalog module, making the models and service available to other parts of the application.

## 2. Implement Product Models [pending]
### Dependencies: 4.1
### Description: Create the data models for products, including Product, NewProduct, and ProductFilter structs.
### Details:
Create the file `src/catalog/models.rs` with the provided code that defines the Product, NewProduct, and ProductFilter structs. These models will represent the core data structures for the product catalog functionality.

## 3. Implement Product Service [pending]
### Dependencies: 4.2
### Description: Create the service layer for product management with CRUD operations and filtering capabilities.
### Details:
Create the file `src/catalog/service.rs` with the provided code that implements the ProductService struct with methods for creating, retrieving, updating, and filtering products. This service will handle the business logic for product management.

## 4. Update Dependencies in Cargo.toml [pending]
### Dependencies: None
### Description: Add the necessary dependencies for the product catalog module to the Cargo.toml file.
### Details:
Update the `Cargo.toml` file to add the rust_decimal dependency with serde feature enabled. This dependency is required for handling monetary values in the product catalog.

## 5. Integrate Product Catalog with Main Application [pending]
### Dependencies: 4.1, 4.2, 4.3, 4.4
### Description: Connect the product catalog module with the main application by registering it in the application context.
### Details:
Update the main application file (likely `src/main.rs` or `src/lib.rs`) to import and initialize the ProductService. Add code to register the service in the application's dependency injection container or global state. Example: `let product_service = ProductService::new(); // Then store or provide access to this service`

