# Task 4: Product Catalog Module

## Description
Create product catalog and inventory management functionality.

## Implementation Details
Implement the product catalog module with inventory management:

1. Create `src/catalog/mod.rs` to export the catalog module components:
```rust
pub mod models;
pub mod service;

pub use self::models::Product;
pub use self::service::ProductService;
```

2. Create `src/catalog/models.rs` for product models:
```rust
use serde::{Serialize, Deserialize};
use rust_decimal::Decimal;

#[derive(Debug, Serialize, Deserialize)]
pub struct Product {
    pub id: i32,
    pub name: String,
    pub description: String,
    pub price: Decimal,
    pub inventory_count: i32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NewProduct {
    pub name: String,
    pub description: String,
    pub price: Decimal,
    pub inventory_count: i32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ProductFilter {
    pub name_contains: Option<String>,
    pub min_price: Option<Decimal>,
    pub max_price: Option<Decimal>,
    pub in_stock: Option<bool>,
}
```

3. Create `src/catalog/service.rs` for product service logic:
```rust
use crate::catalog::models::{Product, NewProduct, ProductFilter};
use rust_decimal::Decimal;
use std::sync::{Arc, Mutex};

// In a real app, this would interact with the database
pub struct ProductService {
    products: Arc<Mutex<Vec<Product>>>,
    next_id: Arc<Mutex<i32>>,
}

impl ProductService {
    pub fn new() -> Self {
        ProductService {
            products: Arc::new(Mutex::new(Vec::new())),
            next_id: Arc::new(Mutex::new(1)),
        }
    }
    
    pub fn create(&self, new_product: NewProduct) -> Product {
        let mut products = self.products.lock().unwrap();
        let mut next_id = self.next_id.lock().unwrap();
        
        let product = Product {
            id: *next_id,
            name: new_product.name,
            description: new_product.description,
            price: new_product.price,
            inventory_count: new_product.inventory_count,
        };
        
        *next_id += 1;
        products.push(product.clone());
        product
    }
    
    pub fn get_all(&self) -> Vec<Product> {
        let products = self.products.lock().unwrap();
        products.clone()
    }
    
    pub fn get_by_id(&self, id: i32) -> Option<Product> {
        let products = self.products.lock().unwrap();
        products.iter().find(|p| p.id == id).cloned()
    }
    
    pub fn update_inventory(&self, id: i32, new_count: i32) -> Option<Product> {
        let mut products = self.products.lock().unwrap();
        if let Some(product) = products.iter_mut().find(|p| p.id == id) {
            product.inventory_count = new_count;
            Some(product.clone())
        } else {
            None
        }
    }
    
    pub fn filter(&self, filter: ProductFilter) -> Vec<Product> {
        let products = self.products.lock().unwrap();
        products
            .iter()
            .filter(|p| {
                let name_match = filter.name_contains
                    .as_ref()
                    .map_or(true, |name| p.name.to_lowercase().contains(&name.to_lowercase()));
                
                let min_price_match = filter.min_price
                    .as_ref()
                    .map_or(true, |min| p.price >= *min);
                
                let max_price_match = filter.max_price
                    .as_ref()
                    .map_or(true, |max| p.price <= *max);
                
                let in_stock_match = filter.in_stock
                    .map_or(true, |in_stock| (p.inventory_count > 0) == in_stock);
                
                name_match && min_price_match && max_price_match && in_stock_match
            })
            .cloned()
            .collect()
    }
}
```

4. Update `Cargo.toml` to add catalog dependencies:
```toml
[dependencies]
rust_decimal = { version = "1.30", features = ["serde"] }
```

## Test Strategy
1. Verify that all required files are created: `src/catalog/mod.rs`, `src/catalog/models.rs`, and `src/catalog/service.rs`
2. Compile the code to ensure there are no syntax errors
3. Write unit tests to verify product creation, retrieval, and inventory management
4. Test the product filtering functionality with various filter combinations
5. Verify that the catalog dependencies in `Cargo.toml` are correctly specified and can be resolved
6. Check that the Product models can be serialized and deserialized correctly
